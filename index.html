<!DOCTYPE html>
<html>
<head>
    <title>íš¨ë¹ˆê´‘ì—­ì‹œ ì „ìì§€ë„ (v3.9 ì´ë¯¸ì§€ ìº¡ì²˜)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
    <script src="hyobin_data.js"></script>
    <script src="hyobin_subway.js"></script>
    <script src="hyobin_markers.js"></script> 

    <style>
        body { margin: 0; background-color: #aaddff; font-family: 'Malgun Gothic', sans-serif; } 
        #map { width: 100vw; height: 100vh; cursor: default; }
        
        .leaflet-popup-content-wrapper { border-radius: 8px; text-align: center; }
        .leaflet-popup-content b { font-size: 1.1em; }
        
        /* í–‰ì •êµ¬ì—­ ë¼ë²¨ */
        .district-label {
            background: transparent; border: none; box-shadow: none;
            font-weight: 900; color: white; text-shadow: 2px 2px 4px #000;
            font-size: 14px; text-align: center; white-space: nowrap;
        }

        /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .control-panel {
            position: absolute; top: 10px; left: 50px; z-index: 1000;
            display: flex; flex-direction: column; gap: 8px;
            max-height: 90vh;
        }
        
        /* ê²€ìƒ‰ì°½ */
        .search-group { display: flex; gap: 5px; margin-bottom: 5px; }
        .search-input {
            padding: 8px; border: 2px solid #333; border-radius: 5px; width: 200px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-weight: bold; outline: none;
        }
        .search-btn {
            background: #0077DD; color: white; border: 2px solid #0055aa; border-radius: 5px;
            cursor: pointer; font-weight: bold; width: 50px;
        }

        /* ë²„íŠ¼ ê·¸ë£¹ */
        .btn-group { display: flex; gap: 5px; flex-wrap: wrap; max-width: 450px; }
        .map-btn {
            background: white; border: 2px solid #333; border-radius: 5px;
            padding: 8px 12px; font-weight: bold; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 13px; color: #333;
        }
        .map-btn:hover { background: #eee; }
        .active-btn { background: #333 !important; color: white !important; border-color: white !important; }
        #clear-btn { border-color: red; color: red; }
        #unit-btn { border-color: #009900; color: #009900; }
        #capture-btn { border-color: #881188; color: #881188; } /* ìº¡ì²˜ ë²„íŠ¼ ìƒ‰ìƒ */

        /* ì§€í•˜ì²  ì„ íƒ ë°•ìŠ¤ */
        .subway-select {
            background: white; border: 2px solid #0077DD; border-radius: 5px;
            padding: 8px; font-weight: bold; cursor: pointer; color: #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 13px; outline: none;
        }

        /* ìƒ‰ìƒ ì„ íƒê¸° */
        .color-picker-box {
            background: rgba(255, 255, 255, 0.95); padding: 0; border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); font-size: 12px; width: 180px; overflow: hidden;
        }
        .picker-header {
            padding: 10px; background: #f8f9fa; cursor: pointer; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd;
        }
        .picker-header:hover { background: #eee; }
        #current-color-preview { width: 20px; height: 20px; border-radius: 3px; border: 1px solid #999; margin-right: 5px; }
        #palette-list { display: none; padding: 10px; max-height: 300px; overflow-y: auto; }
        .color-option { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 4px 0; border-bottom: 1px solid #eee; }
        .color-option:last-child { border-bottom: none; }
        .color-option:hover { background: #f0f0f0; }
        .color-preview-small { width: 16px; height: 16px; border-radius: 3px; border: 1px solid #ccc; }

        /* ë…¸ì„  í•„í„° ë°•ìŠ¤ (ë…¸ì„ ë„ ëª¨ë“œ ì „ìš©) */
        .subway-filter-box {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333; border-radius: 8px;
            padding: 10px;
            margin-top: 5px;
            display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            max-width: 220px;
        }
        .filter-title { font-weight: bold; font-size: 13px; margin-bottom: 8px; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        .filter-list { max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; }
        .filter-item { font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .filter-color-dot { width: 10px; height: 10px; border-radius: 2px; }


        /* ëª¨ë‹¬ì°½ */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center;
        }
        .modal-content { background: white; padding: 20px; border-radius: 15px; text-align: center; width: 340px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .color-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .color-btn { 
            width: 100%; height: 40px; border-radius: 5px; border: 1px solid #ddd; 
            cursor: pointer; font-size: 11px; color: white; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .cancel-btn { background: #eee; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; }
        .confirm-btn { background: #333; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-left: 5px;}

        /* ì—­ ì¶”ê°€ ëª¨ë‹¬ */
        .station-lines-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 15px 0; text-align: left;
            max-height: 250px; overflow-y: auto;
        }
        .line-checkbox-label { display: flex; align-items: center; gap: 5px; font-size: 13px; cursor: pointer; }
        .line-color-box { width: 12px; height: 12px; border-radius: 2px; }

        /* ì§€í•˜ì²  ì—­ ì•„ì´ì½˜ */
        .station-circle {
            background: white; border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3); box-sizing: border-box;
        }
        .station-transfer {
            background: white; border: 2px solid black; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            gap: 2px; padding: 0 3px; box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
        .transfer-dot { width: 8px; height: 8px; border-radius: 50%; }
        .station-name-label {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            white-space: nowrap; font-size: 12px; font-weight: bold;
            color: black; text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            pointer-events: none;
        }
        
        /* íˆ´íŒ ë° ë±ƒì§€ */
        .dist-tooltip {
            background: rgba(0, 0, 0, 0.8); border: 1px solid white; color: #fff;
            font-weight: bold; font-size: 12px; padding: 2px 5px; border-radius: 4px;
        }
        .dist-badge {
            background: #fff; border: 2px solid #333; color: #333;
            font-size: 11px; font-weight: 900; padding: 2px 5px;
            border-radius: 10px; box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            white-space: nowrap; z-index: 1000;
        }
        /* ë©´ì  ê²°ê³¼ ë±ƒì§€ */
        .area-result-badge {
            background: #fff; border: 2px solid #009900; color: #009900;
            font-size: 13px; font-weight: 900; padding: 4px 8px;
            border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            white-space: nowrap; cursor: pointer;
        }
        .area-result-badge:hover { background-color: #eaffea; }

        /* ì—­ê°„ ê±°ë¦¬ ìë™í‘œì‹œ ë±ƒì§€ */
        .auto-dist-badge {
            background: #fff; border: 1px solid #666; color: #555;
            font-size: 10px; font-weight: bold; padding: 1px 3px;
            border-radius: 3px; white-space: nowrap; opacity: 0.9;
        }

        /* êµ¬ì—­ ë©´ì  ì •ë³´ ë±ƒì§€ */
        .area-info-badge {
            background: rgba(255, 255, 255, 0.85); border: 1px solid #555; color: #000;
            font-size: 10px; font-weight: bold; padding: 1px 4px;
            border-radius: 3px; white-space: nowrap; pointer-events: none;
        }
    </style>
</head>
<body>

<div class="control-panel">
    <div class="search-group">
        <input type="text" id="search-input" class="search-input" placeholder="ì¥ì†Œ, ì—­, ë™ ê²€ìƒ‰..." onkeypress="if(event.key==='Enter') searchLocation()">
        <button class="search-btn" onclick="searchLocation()">ğŸ”</button>
    </div>

    <div class="btn-group">
        <button id="draw-btn" class="map-btn" onclick="toggleDrawMode()">ğŸ“ ì„  ê·¸ë¦¬ê¸°</button>
        <button id="area-btn" class="map-btn" onclick="toggleAreaMode()">ğŸ“ ë©´ì  ì¸¡ì •</button>
        <button id="unit-btn" class="map-btn" onclick="toggleUnit()">ğŸ”„ ë‹¨ìœ„: kmÂ²</button>
        <button id="auto-dist-btn" class="map-btn" onclick="toggleAutoDistance()">ğŸ“ ì—­ê°„ ê±°ë¦¬(ìë™)</button>
        <button id="auto-area-btn" class="map-btn" onclick="toggleDistrictArea()">ğŸ“Š êµ¬ì—­ë³„ ë©´ì </button>
        <button id="capture-btn" class="map-btn" onclick="downloadMapImage()">ğŸ“¸ ì§€ë„ ìº¡ì²˜</button>
        <button id="station-btn" class="map-btn" onclick="toggleStationMode()">ğŸš‰ ì—­ ì¶”ê°€</button>
        <button id="save-btn" class="map-btn" onclick="saveData()">ğŸ’¾ ì €ì¥(JSON)</button>
        <button id="load-btn" class="map-btn" onclick="document.getElementById('file-input').click()">ğŸ“‚ ì—´ê¸°</button>
        <button id="clear-btn" class="map-btn" onclick="clearAllData()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
        <button id="mode-btn" class="map-btn" onclick="toggleSubwayMode()">ğŸš‡ ë…¸ì„ ë„ ëª¨ë“œ</button>
    </div>
    
    <input type="file" id="file-input" style="display: none;" accept=".json" onchange="loadData(this)">
    
    <div id="subway-filter-box" class="subway-filter-box">
        <div class="filter-title">
            ğŸš‡ ë…¸ì„ ë³„ ë³´ê¸° 
            <button onclick="toggleAllSubwayFilters(true)" style="font-size:10px; cursor:pointer;">ëª¨ë‘ì„ íƒ</button>
            <button onclick="toggleAllSubwayFilters(false)" style="font-size:10px; cursor:pointer;">í•´ì œ</button>
        </div>
        <div id="subway-filter-list" class="filter-list"></div>
    </div>

    <select id="subway-select" class="subway-select" onchange="selectSubwayLine(this.value)">
        <option value="">ğŸš‡ ë„ì‹œì² ë„ ë…¸ì„  ì„ íƒ...</option>
        <option value="1">ğŸŸ¦ 1í˜¸ì„  (íŒŒë‘)</option>
        <option value="1B">ğŸŸ¦ 1í˜¸ì„  ì§€ì„ </option>
        <option value="2">ğŸŸ© 2í˜¸ì„  (ì´ˆë¡)</option>
        <option value="2B">ğŸŸ© 2í˜¸ì„  ì§€ì„ </option>
        <option value="3">ğŸŸ¨ 3í˜¸ì„  (ë…¸ë‘)</option>
        <option value="4">ğŸŸ§ 4í˜¸ì„  (ì£¼í™©)</option>
        <option value="5">ğŸŸ¥ 5í˜¸ì„  (ë¹¨ê°•)</option>
        <option value="6">ğŸŸª 6í˜¸ì„  (ë³´ë¼)</option>
        <option value="7">ğŸŒ¸ 7í˜¸ì„  (ë¶„í™)</option>
        <option value="7B">ğŸŒ¸ 7í˜¸ì„  ì§€ì„ </option>
        <option value="8">ğŸ”® 8í˜¸ì„  (ì—°ë³´ë¼)</option>
        <option value="B">ğŸš† ë¹ˆíš¨ì„  (ì—°ì²­)</option>
    </select>

    <div class="color-picker-box">
        <div class="picker-header" onclick="togglePaletteList()">
            <div style="display:flex; align-items:center;">
                <div id="current-color-preview"></div><span>ìƒ‰ìƒ ì„ íƒ</span>
            </div>
            <span id="toggle-icon">â–¼</span>
        </div>
        <div id="palette-list"></div>
    </div>
</div>

<div id="color-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin:0">êµ¬ì—­/ë§ˆì»¤ ì„ íƒ</h3>
        <div class="color-grid" id="modal-color-buttons"></div>
        <button class="cancel-btn" onclick="closeModal('color-modal')">ì·¨ì†Œ</button>
    </div>
</div>

<div id="station-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="margin:0">ğŸš‰ ì—­ ì •ë³´ ì…ë ¥</h3>
        <div style="margin-top:10px;">
            <input type="text" id="station-name-input" placeholder="ì—­ ì´ë¦„ (ì˜ˆ: ì„œìš¸ì—­)" style="width:90%; padding:8px; font-size:14px; font-weight:bold; text-align:center;">
        </div>
        <div class="station-lines-grid" id="station-lines-container"></div>
        <button class="cancel-btn" onclick="closeModal('station-modal')">ì·¨ì†Œ</button>
        <button class="confirm-btn" onclick="confirmAddStation()">ì¶”ê°€</button>
    </div>
</div>

<div id="map"></div>

<script>
    // =========================================================
    // â˜… [ì¢Œí‘œ ìë™ ë³´ì • ë¡œì§]
    // =========================================================
    var addedRowsTop = 11;
    var cellHeightForAdj = 1802;
    var adjustY = -(addedRowsTop * cellHeightForAdj); 

    var migrationKey = 'hyobin_v3.0_migration_done';
    if (!localStorage.getItem(migrationKey)) {
        var savedMarkers = JSON.parse(localStorage.getItem('hyobin_markers')) || [];
        var savedLines = JSON.parse(localStorage.getItem('hyobin_lines')) || [];
        if (savedMarkers.length > 0 || savedLines.length > 0) {
            console.log(`[ì‹œìŠ¤í…œ] ì¢Œí‘œ ìë™ ë³´ì • ì‹¤í–‰ (Yì¶• ${adjustY})`);
            savedMarkers.forEach(m => { m.lat += adjustY; });
            savedLines.forEach(l => { l.points = l.points.map(p => [p[0] + adjustY, p[1]]); });
            localStorage.setItem('hyobin_markers', JSON.stringify(savedMarkers));
            localStorage.setItem('hyobin_lines', JSON.stringify(savedLines));
        }
        localStorage.setItem(migrationKey, 'true');
    }

    function shiftPoints(points) {
        if (Array.isArray(points[0][0])) { return points.map(ring => ring.map(p => [p[0] + adjustY, p[1]])); } 
        else { return points.map(p => [p[0] + adjustY, p[1]]); }
    }

    // =========================================================
    // 1. ì „ì—­ ì„¤ì •
    // =========================================================
    var isDrawingMode = false;      
    var isStationMode = false;
    var isAreaMode = false;
    var isAutoDistMode = false; 
    var isDistrictAreaMode = false; 
    var useKmUnit = true; 
    
    var searchablePolygons = []; 
    var tempClickLatLng = null;      

    var regionColors = [
        { name: "íš¨ë¹ˆì‹œ(ëŒ€í‘œ)", code: "#7777aa" },
        { name: "ì¤‘êµ¬", code: "#BB9955" },
        { name: "ë™êµ¬", code: "#FF9922" },
        { name: "ì„œêµ¬", code: "#00AABB" },
        { name: "ë‚¨êµ¬", code: "#DDBBFF" },
        { name: "ë¶êµ¬", code: "#7799CC" },
        { name: "ì²­ì—½êµ¬", code: "#006699" },
        { name: "ì°½ì „êµ¬", code: "#33AAFF" },
        { name: "ì•ˆì²œêµ¬", code: "#AA66DD" },
        { name: "íƒ„ì„±êµ°", code: "#BBFF64" },
        { name: "ì„ ê³¡êµ°(ë•ë¹ˆ)", code: "#D6D5CA" },
        { name: "ê¸°ë„êµ°(ë•ë¹ˆ)", code: "#01B7ED" },
        { name: "ì²œì£¼ì‹œ(ë•ë¹ˆ)", code: "#8B4993" },
        { name: "ì•½ì‚°ì‹œ(ë•ë¹ˆ)", code: "#F8C8C4" },
        { name: "ë•í˜„êµ°(ë•ë¹ˆ)", code: "#FF5800" }
    ];

    function getColorByName(name) {
        var found = regionColors.find(function(rc) { return rc.name === name; });
        if (found) return found.code;
        found = regionColors.find(function(rc) { return name.indexOf(rc.name.replace("ì²­", "")) !== -1 && rc.name.length > 2; }); 
        if (found) return found.code;
        return "#999999";
    }

    var subwayLines = {
        "1": { name: "1í˜¸ì„ ", color: "#0077DD" },
        "1B": { name: "1í˜¸ì„ (ì§€ì„ )", color: "#0077DD" },
        "2": { name: "2í˜¸ì„ ", color: "#00CCAA" },
        "2B": { name: "2í˜¸ì„ (ì§€ì„ )", color: "#00CCAA" },
        "3": { name: "3í˜¸ì„ ", color: "#FFCC11" },
        "4": { name: "4í˜¸ì„ ", color: "#FF5522" },
        "5": { name: "5í˜¸ì„ ", color: "#EE0022" },
        "6": { name: "6í˜¸ì„ ", color: "#881188" },
        "7": { name: "7í˜¸ì„ ", color: "#FF8899" },
        "7B": { name: "7í˜¸ì„ (ì§€ì„ )", color: "#FF8899" },
        "8": { name: "8í˜¸ì„ ", color: "#9856FF" },
        "B": { name: "ë¹ˆíš¨ì„ ", color: "#6677CC" }
    };

    var currentSelectedColor = regionColors[0].code;

    function updateHeaderPreview(color) { document.getElementById('current-color-preview').style.backgroundColor = color; }
    updateHeaderPreview(currentSelectedColor);

    var paletteContainer = document.getElementById('palette-list');
    regionColors.forEach((rc, index) => {
        var label = document.createElement('label'); label.className = 'color-option';
        var radio = document.createElement('input'); radio.type = 'radio'; radio.name = 'drawColor'; radio.value = rc.code;
        if (index === 0) radio.checked = true;
        radio.onclick = function() { 
            currentSelectedColor = rc.code; 
            updateHeaderPreview(rc.code);
            document.getElementById('subway-select').value = "";
        };
        var box = document.createElement('div'); box.className = 'color-preview-small'; box.style.backgroundColor = rc.code;
        var text = document.createTextNode(rc.name);
        label.appendChild(radio); label.appendChild(box); label.appendChild(text); paletteContainer.appendChild(label);
    });

    // ë…¸ì„  í•„í„° ëª©ë¡ ìƒì„±
    var filterContainer = document.getElementById('subway-filter-list');
    for (const [key, val] of Object.entries(subwayLines)) {
        var label = document.createElement('label'); label.className = 'line-checkbox-label';
        var checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.value = key; checkbox.name = 'stationLine';
        var colorBox = document.createElement('div'); colorBox.className = 'line-color-box'; colorBox.style.backgroundColor = val.color;
        label.appendChild(checkbox); label.appendChild(colorBox); label.appendChild(document.createTextNode(val.name));
        document.getElementById('station-lines-container').appendChild(label);

        var filterItem = document.createElement('label'); filterItem.className = 'filter-item';
        var fChk = document.createElement('input'); fChk.type = 'checkbox'; fChk.value = key; fChk.checked = true; fChk.name = 'subwayFilter';
        fChk.onchange = applySubwayFilter; 
        var fDot = document.createElement('div'); fDot.className = 'filter-color-dot'; fDot.style.backgroundColor = val.color;
        filterItem.appendChild(fChk); filterItem.appendChild(fDot); filterItem.appendChild(document.createTextNode(val.name));
        filterContainer.appendChild(filterItem);
    }

    function togglePaletteList() {
        var list = document.getElementById('palette-list');
        var icon = document.getElementById('toggle-icon');
        if (list.style.display === 'block') { list.style.display = 'none'; icon.innerText = 'â–¼'; } 
        else { list.style.display = 'block'; icon.innerText = 'â–²'; }
    }

    function selectSubwayLine(val) {
        if (!val) return;
        var line = subwayLines[val];
        currentSelectedColor = line.color;
        updateHeaderPreview(line.color);
        
        isStationMode = false;
        isAreaMode = false;
        document.getElementById('station-btn').classList.remove('active-btn');
        document.getElementById('area-btn').classList.remove('active-btn');
        document.getElementById('map').style.cursor = "default";

        if (!isDrawingMode) toggleDrawMode();
        alert(`${line.name} ì„ íƒë¨! ì§€ë„ë¥¼ í´ë¦­í•´ì„œ ë…¸ì„ ì„ ê·¸ë¦¬ì„¸ìš”.`);
    }

    function toggleDrawMode() {
        isStationMode = false; isAreaMode = false;
        document.getElementById('station-btn').classList.remove('active-btn');
        document.getElementById('area-btn').classList.remove('active-btn');

        isDrawingMode = !isDrawingMode; 
        var btn = document.getElementById("draw-btn");
        if (isDrawingMode) {
            btn.classList.add("active-btn"); 
            btn.innerHTML = "âœï¸ ê·¸ë¦¬ëŠ” ì¤‘... (ìš°í´ë¦­ ì¢…ë£Œ)";
            document.getElementById("map").style.cursor = "crosshair"; 
            drawPoints = [];
            currentDrawMarkers = [];
        } else { 
            resetDrawMode(); 
        }
    }

    function toggleAreaMode() {
        isDrawingMode = false; isStationMode = false;
        document.getElementById('draw-btn').classList.remove('active-btn');
        document.getElementById('station-btn').classList.remove('active-btn');
        resetDrawMode(); 

        isAreaMode = !isAreaMode;
        var btn = document.getElementById("area-btn");
        if (isAreaMode) {
            btn.classList.add("active-btn");
            btn.innerHTML = "ğŸ“ ì°ëŠ” ì¤‘... (ìš°í´ë¦­ ì™„ë£Œ)";
            document.getElementById("map").style.cursor = "cell";
            areaPoints = [];
        } else {
            resetAreaMode();
        }
    }

    function toggleUnit() {
        useKmUnit = !useKmUnit;
        var btn = document.getElementById('unit-btn');
        btn.innerHTML = useKmUnit ? "ğŸ”„ ë‹¨ìœ„: kmÂ²" : "ğŸ”„ ë‹¨ìœ„: mÂ²";
        if (isDistrictAreaMode) {
            updateDistrictAreaLabels();
        }
    }

    function formatArea(area) {
        if (useKmUnit) {
            return (area / 1000000).toFixed(2) + "kmÂ²";
        } else {
            return Math.round(area).toLocaleString() + "mÂ²";
        }
    }
    
    // =========================================================
    // êµ¬ì—­ë³„ ë©´ì  ìë™ ê³„ì‚° (ë ˆì´ì–´ ì—°ë™)
    // =========================================================
    var districtAreaLabels = [];

    function toggleDistrictArea() {
        var btn = document.getElementById('auto-area-btn');
        isDistrictAreaMode = !isDistrictAreaMode;

        if (isDistrictAreaMode) {
            btn.classList.add('active-btn');
            updateDistrictAreaLabels();
            alert("ì¼œì§„ ë ˆì´ì–´(í–‰ì •ë™/ë²•ì •ë™ ë“±)ì˜ ë©´ì ë§Œ í‘œì‹œí•©ë‹ˆë‹¤.");
        } else {
            btn.classList.remove('active-btn');
            clearDistrictAreaLabels();
        }
    }

    function clearDistrictAreaLabels() {
        districtAreaLabels.forEach(lbl => map.removeLayer(lbl));
        districtAreaLabels = [];
    }

    function updateDistrictAreaLabels() {
        clearDistrictAreaLabels();
        if (!isDistrictAreaMode) return;

        var showGugun = map.hasLayer(guGunLayer);
        var showAdmin = map.hasLayer(adminLayer);
        var showLegal = map.hasLayer(legalLayer);
        var showDev   = map.hasLayer(devLayer);

        if (!showGugun && !showAdmin && !showLegal && !showDev) return;

        searchablePolygons.forEach(function(poly) {
            var isVisible = false;
            if (poly.type === 'gugun' && showGugun) isVisible = true;
            else if (poly.type === 'admin' && showAdmin) isVisible = true;
            else if (poly.type === 'legal' && showLegal) isVisible = true;
            else if (poly.type === 'dev' && showDev) isVisible = true;

            if (isVisible) {
                var area = calculatePolygonArea(poly.points);
                var areaStr = formatArea(area);
                var center = L.polygon(poly.points).getBounds().getCenter();

                var label = L.marker(center, {
                    icon: L.divIcon({
                        className: 'area-info-wrap',
                        html: `<div class="area-info-badge">${areaStr}</div>`,
                        iconSize: null,
                        iconAnchor: [15, 0] 
                    }),
                    interactive: false
                }).addTo(map);

                districtAreaLabels.push(label);
            }
        });
    }

    function calculatePolygonArea(points) {
        var areaSum = 0;
        for (var i = 0; i < points.length; i++) {
            var p1 = points[i];
            var p2 = points[(i + 1) % points.length];
            areaSum += (p1[1] * p2[0] - p2[1] * p1[0]);
        }
        return Math.abs(areaSum) / 2.0;
    }


    // =========================================================
    // ì—­ê°„ ê±°ë¦¬ ìë™ ê³„ì‚° ë° í‘œì‹œ
    // =========================================================
    var autoDistanceLabels = [];

    function toggleAutoDistance() {
        var btn = document.getElementById('auto-dist-btn');
        isAutoDistMode = !isAutoDistMode;

        if (isAutoDistMode) {
            btn.classList.add('active-btn');
            if (typeof subwayData !== 'undefined' && subwayData.lines) {
                calculateAndShowDistances();
                if(isSubwayMode) applySubwayFilter();
            } else {
                alert("ì§€í•˜ì²  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                isAutoDistMode = false;
                btn.classList.remove('active-btn');
            }
        } else {
            btn.classList.remove('active-btn');
            autoDistanceLabels.forEach(lbl => map.removeLayer(lbl));
            autoDistanceLabels = [];
        }
    }

    function calculateAndShowDistances() {
        var stations = allLandmarks.filter(m => m.type === 'subway');
        var linesData = subwayData.lines;

        linesData.forEach(line => {
            var lineKey = Object.keys(subwayLines).find(key => subwayLines[key].name === line.name);
            if (!lineKey) {
                lineKey = Object.keys(subwayLines).find(key => line.name.includes(subwayLines[key].name) || subwayLines[key].name.includes(line.name));
            }
            if (!lineKey) return; 

            var lineStations = stations.filter(s => s.lines.includes(lineKey));
            if (lineStations.length < 2) return;

            var linePoints = line.points.map(p => [p[0] + adjustY, p[1]]);

            lineStations.forEach(st => {
                st._lineIndex = findClosestPointIndex([st.lat, st.lng], linePoints);
            });

            lineStations.sort((a, b) => a._lineIndex - b._lineIndex);

            for (var i = 0; i < lineStations.length - 1; i++) {
                var st1 = lineStations[i];
                var st2 = lineStations[i+1];
                
                var dist = calculatePathDistance(linePoints, st1._lineIndex, st2._lineIndex);
                
                if (dist > 0) {
                    var distStr = (dist >= 1000) ? (dist/1000).toFixed(1) + "km" : Math.round(dist) + "m";
                    var midIdx = Math.floor((st1._lineIndex + st2._lineIndex) / 2);
                    var midPoint = linePoints[midIdx];

                    var label = L.marker(midPoint, {
                        icon: L.divIcon({
                            className: 'auto-dist-wrap',
                            html: `<div class="auto-dist-badge" style="border-color:${line.color};">${distStr}</div>`,
                            iconSize: null,
                            iconAnchor: [15, 0]
                        }),
                        interactive: false 
                    }).addTo(map);
                    
                    label.relatedLineId = lineKey;
                    autoDistanceLabels.push(label);
                }
            }
        });
        alert("ëª¨ë“  ë…¸ì„ ì˜ ì—­ê°„ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ í‘œì‹œí–ˆìŠµë‹ˆë‹¤.");
    }

    function findClosestPointIndex(latlng, points) {
        var minDest = Infinity;
        var index = -1;
        for (var i = 0; i < points.length; i++) {
            var d = map.distance(latlng, points[i]);
            if (d < minDest) {
                minDest = d;
                index = i;
            }
        }
        return index;
    }

    function calculatePathDistance(points, idx1, idx2) {
        var dist = 0;
        var start = Math.min(idx1, idx2);
        var end = Math.max(idx1, idx2);
        for(var i=start; i<end; i++) {
            dist += map.distance(points[i], points[i+1]);
        }
        return dist;
    }


    function toggleStationMode() {
        resetDrawMode(); resetAreaMode();
        isStationMode = !isStationMode;
        var btn = document.getElementById("station-btn");
        if (isStationMode) {
            btn.classList.add("active-btn");
            btn.innerHTML = "ğŸš‰ ì—­ ìœ„ì¹˜ í´ë¦­";
            document.getElementById("map").style.cursor = "pointer";
        } else {
            btn.classList.remove("active-btn");
            btn.innerHTML = "ğŸš‰ ì—­ ì¶”ê°€";
            document.getElementById("map").style.cursor = "default";
        }
    }

    function resetDrawMode() {
        isDrawingMode = false;
        var btn = document.getElementById("draw-btn");
        btn.classList.remove("active-btn"); 
        btn.innerHTML = "ğŸ“ ì„  ê·¸ë¦¬ê¸°";
        document.getElementById("map").style.cursor = "default";
        
        if (drawPolyline) map.removeLayer(drawPolyline); 
        if (tempLine) map.removeLayer(tempLine); 
        
        if (currentDrawMarkers) {
            currentDrawMarkers.forEach(m => map.removeLayer(m));
            currentDrawMarkers = [];
        }
        drawPoints = [];
    }

    function resetAreaMode() {
        isAreaMode = false;
        var btn = document.getElementById("area-btn");
        btn.classList.remove("active-btn");
        btn.innerHTML = "ğŸ“ ë©´ì  ì¸¡ì •";
        document.getElementById("map").style.cursor = "default";

        if (areaPolygon) map.removeLayer(areaPolygon);
        if (tempAreaLine) map.removeLayer(tempAreaLine);
        areaPoints = [];
    }

    // =========================================================
    // 3. ì§€ë„ ìƒì„± ë° ë°ì´í„° ë¡œë”©
    // =========================================================
    var baseMarkerSize = 40; var sizeMultiplier = 8; var minMarkerSize = 10;
    function createCustomIcon(color, size) {
        if (!color) color = "#333333"; if (!size) size = baseMarkerSize;
        var svgIcon = `<svg viewBox="0 0 384 512" xmlns="http://www.w3.org/2000/svg"><path fill="${color}" stroke="white" stroke-width="20" d="M384 192c0 87.4-117 243-168.3 307.2c-12.3 15.3-35.1 15.3-47.4 0C117 435 0 279.4 0 192C0 86 86 0 192 0s192 86 192 192z"/><circle cx="192" cy="192" r="60" fill="white" /></svg>`;
        return L.divIcon({ className: 'custom-pin', html: svgIcon, iconSize: [size, size * 1.3], iconAnchor: [size / 2, size * 1.3], popupAnchor: [0, -size] });
    }

    var cellWidth = 3829; var cellHeight = 1802;
    var gridLayout = [
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 48, 48, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 48, 48, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 47, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 47, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 47, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 46, null],
        [null, null, null, 37, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 46, null],
        [null, null, null, 37, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 46, null],
        [null, null, null, 36, 36, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 46, null],
        [null, null, null, 36, 36, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 45, null],
        [null, null, null, 36, 36, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 45, null],
        [null, null, null, 7, 7, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 45, null],
        [null, null, null, 7, 7, null, null, null, null, null, null, null, null, null, null, 41, 42, 42, 43, 45, 52],
        [null, null, null, 8, 8, 11, 15, 19, 23, 28, 33, 34, 38, 39, 40, 41, 42, 42, 43, 44, 52],
        [null, null, null, 8, 8, 11, 15, 19, 23, 28, 33, 34, 38, 39, 40, 49, 42, 42, 43, 44, 52],
        [0, 1, null, null, 9, 12, 16, 20, 24, 29, 31, 35, 38, 39, 40, 49, null, null, null, null, null],
        [0, 1, 3, 5, 9, 12, 16, 20, 24, 29, 31, 35, 38, 39, 40, 49, null, null, null, null, null],
        [0, 1, 3, 5, 10, 13, 17, 21, 25, 30, 32, 35, null, null, null, null, null, null, null, null, null],
        [null, 2, 2, 6, 10, 13, 17, 21, 25, 30, 32, null, null, null, null, null, null, null, null, null, null],
        [null, 2, 2, 6, 10, 14, 18, 22, 26, null, null, null, null, null, null, null, null, null, null, null, null],
        [null, 4, 4, 6, null, 14, 18, 22, 26, null, null, null, null, null, null, null, null, null, null, null, null],
        [null, 4, 4, null, null, null, null, 22, 26, null, null, null, null, null, null, null, null, null, null, null, null],
        [null, 4, 4, null, null, null, null, 27, 27, null, null, null, null, null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]
    ];

    var totalHeight = gridLayout.length * cellHeight;
    var totalWidth = gridLayout[0].length * cellWidth;
    var mapBounds = L.latLngBounds([[-totalHeight, 0], [0, totalWidth]]);

    var map = L.map('map', {
        crs: L.CRS.Simple, minZoom: -4.0, maxZoom: 1, zoomSnap: 0.1, zoomDelta: 0.5, attributionControl: false,
        maxBounds: mapBounds, maxBoundsViscosity: 0.8
    });

    var imageLayerGroup = L.layerGroup().addTo(map);
    var placedImages = {};
    for (var row = 0; row < gridLayout.length; row++) {
        for (var col = 0; col < gridLayout[row].length; col++) {
            var imgId = gridLayout[row][col];
            if (imgId === null || placedImages[imgId]) continue;
            var endCol = col; while (endCol + 1 < gridLayout[row].length && gridLayout[row][endCol + 1] === imgId) endCol++;
            var endRow = row; while (endRow + 1 < gridLayout.length && gridLayout[endRow + 1][col] === imgId) endRow++;
            var bounds = [[-((endRow + 1) * cellHeight), col * cellWidth], [-(row * cellHeight), (endCol + 1) * cellWidth]];
            L.imageOverlay("big" + imgId + ".png", bounds).addTo(imageLayerGroup);
            placedImages[imgId] = true;
        }
    }
    map.setView([-totalHeight / 2, totalWidth / 2], -3.5);

    // =========================================================
    // 4. ë ˆì´ì–´ ì •ì˜
    // =========================================================
    var guGunLayer = L.layerGroup();    
    var adminLayer = L.layerGroup();    
    var legalLayer = L.layerGroup();    
    var devLayer = L.layerGroup();      
    var subwayLineLayer = L.layerGroup(); 
    var subwayStationLayer = L.layerGroup(); 

    if (typeof districtData !== 'undefined') {
        districtData.forEach(function(d) {
            var color = d.color || getColorByName(d.name);
            var name = d.name;
            var targetLayer; var layerType = ""; 
            var isNewTown = name.includes("ì‹ ë„ì‹œ") || name.includes("ê°œë°œ") || name.includes("ì§€êµ¬") || name.includes("íƒ€ìš´");
            
            if (d.type === "legal") { targetLayer = legalLayer; layerType = "legal"; } 
            else if (d.type === "admin") { targetLayer = adminLayer; layerType = "admin"; } 
            else if (isNewTown) { targetLayer = devLayer; layerType = "dev"; } 
            else if ((name.endsWith("êµ¬") || name.endsWith("êµ°")) && !name.includes("ì") && !name.includes("ë©´")) { targetLayer = guGunLayer; layerType = "gugun"; } 
            else if (name.includes("ê°€") || name.endsWith("ë¦¬") || name.includes("ì¤‘ì•™ë¡œ") || name === "í›ˆë™") { targetLayer = legalLayer; layerType = "legal"; } 
            else { targetLayer = adminLayer; layerType = "admin"; }
            
            var dashStyle = null; var weightStyle = 1; var opacity = 0.7;
            if (targetLayer === devLayer) { dashStyle = '10, 10'; weightStyle = 4; opacity = 0.9; }
            else if (targetLayer === guGunLayer) { weightStyle = 3; opacity = 1.0; }
            else if (targetLayer === adminLayer) { dashStyle = '5, 5'; weightStyle = 2; opacity = 0.5; }
            else if (targetLayer === legalLayer) { weightStyle = 1; opacity = 0.8; }

            var rawPoints = Array.isArray(d.points[0][0]) ? d.points : [d.points];
            var polyPoints = shiftPoints(rawPoints); 

            polyPoints.forEach(function(polygonPoints) {
                L.polygon(polygonPoints, { color: color, fillColor: color, fillOpacity: 0.15, weight: weightStyle, dashArray: dashStyle, opacity: opacity, interactive: false })
                .addTo(targetLayer);
                searchablePolygons.push({ name: name, type: layerType, points: polygonPoints });
            });
            
            var center = L.polygon(polyPoints[0]).getBounds().getCenter();
            L.marker(center, { icon: L.divIcon({ className: 'district-label', html: name.split('(')[0], iconSize: [120, 20], iconAnchor: [60, 10] }) }).addTo(targetLayer);
        });
    }

    var overlays = { 
        "ğŸ™ï¸ êµ¬/êµ° (ìƒìœ„)": guGunLayer,
        "ğŸ¢ í–‰ì • ì/ë©´/ë™": adminLayer,
        "ì´˜ì´˜ ë²•ì • ë™/ë¦¬": legalLayer,
        "ğŸ—ï¸ ê°œë°œì§€êµ¬": devLayer,
        "ğŸš‡ ì§€í•˜ì²  ë…¸ì„ ": subwayLineLayer,
        "ğŸš‰ ì§€í•˜ì²  ì—­": subwayStationLayer
    };
    L.control.layers(null, overlays, { collapsed: false }).addTo(map);

    // =========================================================
    // 5. ë§ˆì»¤ ë°ì´í„° í†µí•© (íŒŒì¼ì—ì„œ ë¶ˆëŸ¬ì™€ì„œ ì¢Œí‘œ ë³´ì •)
    // =========================================================
    var myLandmarks = JSON.parse(localStorage.getItem('hyobin_markers')) || [];
    myLandmarks.forEach(m => { if(!m.type) m.type = 'normal'; });

    var processedDefaultLandmarks = [];
    if (typeof defaultLandmarksData !== 'undefined') {
        processedDefaultLandmarks = defaultLandmarksData.map(function(m) {
            return {
                name: m.name,
                lat: m.lat + adjustY, 
                lng: m.lng,
                color: m.color,
                type: m.type
            };
        });
    } else {
        console.error("hyobin_markers.js íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    var allLandmarks = processedDefaultLandmarks.concat(myLandmarks);

    if (typeof subwayData !== 'undefined') {
        if (subwayData.markers) {
            subwayData.markers.forEach(m => { m.lat += adjustY; });
            allLandmarks = allLandmarks.concat(subwayData.markers);
        }
        if (subwayData.lines) {
            subwayData.lines.forEach(function(line) {
                var correctedPoints = line.points.map(p => [p[0] + adjustY, p[1]]);
                // [NEW] lineKey ì°¾ì•„ì„œ ë ˆì´ì–´ì— ì‹¬ê¸° (í•„í„°ë§ìš©)
                var lineKey = Object.keys(subwayLines).find(key => subwayLines[key].name === line.name) || "";
                if (!lineKey) lineKey = Object.keys(subwayLines).find(key => line.name.includes(subwayLines[key].name) || subwayLines[key].name.includes(line.name));
                
                var poly = L.polyline(correctedPoints, { color: line.color, weight: 5, opacity: 0.8 });
                poly.bindTooltip(line.name, { sticky: true });
                poly.lineCode = lineKey; // ID ì €ì¥
                poly.addTo(subwayLineLayer);
            });
        }
    }

    var activeMarkers = [];
    allLandmarks.forEach(item => addMarkerToMap(item));
    function calculateSize(zoom) { return Math.max(baseMarkerSize + (zoom * sizeMultiplier), minMarkerSize); }
    
    function addMarkerToMap(item) {
        var size = calculateSize(map.getZoom());
        var marker;

        if (item.type === 'subway') {
            var lines = item.lines || []; 
            var iconHtml = "";
            var width = (lines.length === 1) ? 14 : (lines.length * 10) + 6;

            if (lines.length === 1) {
                var lineInfo = subwayLines[lines[0]];
                var lineColor = lineInfo ? lineInfo.color : "#333";
                iconHtml = `<div class="station-circle" style="width:14px; height:14px; border: 3px solid ${lineColor};"></div>`;
            } else {
                var dotsHtml = "";
                lines.forEach(lid => {
                    var lInfo = subwayLines[lid];
                    var c = lInfo ? lInfo.color : "#333";
                    dotsHtml += `<div class="transfer-dot" style="background-color:${c};"></div>`;
                });
                iconHtml = `<div class="station-transfer" style="width:${width}px; height:14px;">${dotsHtml}</div>`;
            }
            iconHtml += `<div class="station-name-label">${item.name}</div>`;
            
            marker = L.marker([item.lat, item.lng], {
                icon: L.divIcon({ className: 'custom-station', html: iconHtml, iconSize: [width, 14], iconAnchor: [width/2, 7] })
            });

            // [NEW] Marker ê°ì²´ì— ë…¸ì„  ì •ë³´ ì‹¬ê¸° (í•„í„°ë§ìš©)
            marker.lineCodes = lines;

        } else {
            marker = L.marker([item.lat, item.lng], { icon: createCustomIcon(item.color, size) });
        }

        if (item.type === 'subway') {
            marker.addTo(subwayStationLayer); 
        } else {
            marker.addTo(map); 
        }
        
        marker.myColor = item.color; 
        activeMarkers.push(marker);

        if (item.type !== 'subway') {
            marker.bindTooltip(item.name, { offset: [0, -20], direction: 'top' });
        }

        marker.on('dblclick', function(e) {
            L.DomEvent.stopPropagation(e);
            var isUserMarker = myLandmarks.some(m => m.name === item.name && m.lat === item.lat);
            if (isUserMarker) {
                if (confirm(`'${item.name}' ë§ˆì»¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    if (item.type === 'subway') {
                        subwayStationLayer.removeLayer(marker);
                    } else {
                        map.removeLayer(marker);
                    }
                    activeMarkers = activeMarkers.filter(m => m !== marker);
                    myLandmarks = myLandmarks.filter(m => m.name !== item.name || m.lat !== item.lat);
                    localStorage.setItem('hyobin_markers', JSON.stringify(myLandmarks));
                }
            }
        });
    }

    // =========================================================
    // 6. í´ë¦­ ì´ë²¤íŠ¸ ë° ê·¸ë¦¬ê¸° ë¡œì§ (ê±°ë¦¬ ê¼¬ë¦¬í‘œ + í´ë¦­ì‹œ ìƒì„¸ + ë©´ì )
    // =========================================================
    var isDrawing = false; var drawPoints = []; var drawPolyline = null; var tempLine = null;
    var currentDrawMarkers = []; 
    var areaPoints = []; var areaPolygon = null; var tempAreaLine = null;
    
    var myLines = JSON.parse(localStorage.getItem('hyobin_lines')) || [];
    myLines.forEach(lineData => { addLineToMap(lineData); });

    function addLineToMap(lineData) {
        var lineColor = lineData.color || "red"; 
        var polyline = L.polyline(lineData.points, { color: lineColor, weight: 5, opacity: 0.8 }).addTo(map);
        
        var totalDist = 0;
        for(var i=0; i<lineData.points.length-1; i++) {
            totalDist += map.distance(lineData.points[i], lineData.points[i+1]);
        }
        polyline.bindTooltip(`${lineData.name} (ì´ ${Math.round(totalDist)}m)`, { sticky: true });

        polyline.distanceMarkers = [];
        polyline.on('click', function(e) {
            L.DomEvent.stopPropagation(e);
            if (polyline.distanceMarkers.length > 0) {
                polyline.distanceMarkers.forEach(m => map.removeLayer(m));
                polyline.distanceMarkers = [];
            } else {
                var currentTotal = 0;
                lineData.points.forEach((pt, idx) => {
                    if (idx > 0) {
                        currentTotal += map.distance(lineData.points[idx-1], pt);
                    }
                    var labelText = (idx === 0) ? "ì¶œë°œ" : Math.round(currentTotal) + "m";
                    if (idx === lineData.points.length - 1) {
                        labelText = "ğŸ " + Math.round(currentTotal) + "m";
                    }
                    var badgeIcon = L.divIcon({
                        className: 'distance-badge-wrap',
                        html: `<div class="dist-badge" style="border-color:${lineColor}; color:${lineColor}">${labelText}</div>`,
                        iconSize: null,
                        iconAnchor: [0, -5]
                    });
                    var marker = L.marker(pt, { icon: badgeIcon, interactive: false }).addTo(map);
                    polyline.distanceMarkers.push(marker);
                });
            }
        });

        polyline.on('contextmenu', function(e) {
            L.DomEvent.stopPropagation(e);
            if (confirm(`'${lineData.name}' ì„ ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                if (polyline.distanceMarkers.length > 0) {
                    polyline.distanceMarkers.forEach(m => map.removeLayer(m));
                }
                map.removeLayer(polyline);
                myLines = myLines.filter(l => l.name !== lineData.name);
                localStorage.setItem('hyobin_lines', JSON.stringify(myLines));
            }
        });
    }

    function isPointInPolygon(lat, lng, polygonPoints) {
        var x = lat, y = lng;
        var inside = false;
        for (var i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {
            var xi = polygonPoints[i][0], yi = polygonPoints[i][1];
            var xj = polygonPoints[j][0], yj = polygonPoints[j][1];
            var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    map.on('click', function(e) {
        // [ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ]
        if (isDrawingMode) {
            var lat = Math.round(e.latlng.lat); 
            var lng = Math.round(e.latlng.lng);
            drawPoints.push([lat, lng]); 
            redrawLine();
            if (drawPoints.length > 0) {
                var totalDist = 0;
                for(var i=0; i<drawPoints.length-1; i++) totalDist += map.distance(drawPoints[i], drawPoints[i+1]);
                var labelText = (drawPoints.length === 1) ? "ì‹œì‘" : Math.round(totalDist) + "m";
                var distBadge = L.marker([lat, lng], {
                    icon: L.divIcon({ className: 'distance-label', html: `<div class="dist-badge">${labelText}</div>`, iconSize: null, iconAnchor: [0, -10] })
                }).addTo(map);
                currentDrawMarkers.push(distBadge);
            }
            return;
        }

        // [ë©´ì  ì¸¡ì • ëª¨ë“œ]
        if (isAreaMode) {
            var lat = Math.round(e.latlng.lat);
            var lng = Math.round(e.latlng.lng);
            areaPoints.push([lat, lng]);
            
            if (areaPolygon) map.removeLayer(areaPolygon);
            if (areaPoints.length > 0) {
                areaPolygon = L.polygon(areaPoints, { color: "#009900", fillColor: "#00FF00", fillOpacity: 0.3 }).addTo(map);
            }
            return;
        }

        if (isStationMode) {
            tempClickLatLng = { lat: Math.round(e.latlng.lat), lng: Math.round(e.latlng.lng) };
            openStationModal();
            return;
        }

        var lat = e.latlng.lat; var lng = e.latlng.lng;
        var foundGugun = null; var foundAdmin = null; var foundLegal = null;

        searchablePolygons.forEach(function(poly) {
            if (isPointInPolygon(lat, lng, poly.points)) {
                if (poly.type === 'gugun') foundGugun = poly.name;
                else if (poly.type === 'admin') foundAdmin = poly.name;
                else if (poly.type === 'legal') foundLegal = poly.name;
            }
        });

        if (!foundGugun && !foundAdmin && !foundLegal) { return; }

        var province = "íš¨ë¹ˆê´‘ì—­ì‹œ";
        if (foundGugun === "ì„ ê³¡êµ°" || foundGugun === "ê¸°ë„êµ°" || foundGugun === "ë•í˜„êµ°") { province = "ë•ë¹ˆë¶ë„"; }
        if (foundGugun && (foundGugun.includes("ì²œì£¼ì‹œ") || foundGugun.includes("ì•½ì‚°ì‹œ"))) { province = "ë•ë¹ˆë¶ë„"; }

        var fullAddress = province;
        if (foundGugun) fullAddress += " " + foundGugun;
        if (foundAdmin) fullAddress += " " + foundAdmin;
        if (foundLegal && foundLegal !== foundAdmin) {
            if (foundLegal.endsWith("ë¦¬")) { fullAddress += " " + foundLegal; } 
            else { fullAddress += "(" + foundLegal + ")"; }
        }

        L.popup().setLatLng(e.latlng).setContent(`<div style="font-size:14px; text-align:center; padding:5px;">ğŸ“ <b>ìœ„ì¹˜ ì •ë³´</b><br><hr style="margin:6px 0; border:0; border-top:1px solid #ccc;">${fullAddress}</div>`).openOn(map);
    });

    map.on('mousemove', function(e) {
        if (isDrawingMode && drawPoints.length > 0) {
            var lastPoint = drawPoints[drawPoints.length - 1];
            if (tempLine) map.removeLayer(tempLine);
            var currentDist = map.distance(lastPoint, e.latlng);
            var totalDist = 0;
            for(var i=0; i<drawPoints.length-1; i++) totalDist += map.distance(drawPoints[i], drawPoints[i+1]);
            totalDist += currentDist;
            tempLine = L.polyline([lastPoint, e.latlng], { color: currentSelectedColor, dashArray: '5, 10', weight: 2 }).addTo(map);
            tempLine.bindTooltip("ì´ " + Math.round(totalDist) + "m", { permanent: true, direction: 'right', className: 'dist-tooltip' }).openTooltip(e.latlng);
        }
        
        if (isAreaMode && areaPoints.length > 0) {
            var lastPoint = areaPoints[areaPoints.length - 1];
            if (tempAreaLine) map.removeLayer(tempAreaLine);
            tempAreaLine = L.polyline([lastPoint, e.latlng], { color: "#009900", dashArray: '5, 5', weight: 2 }).addTo(map);
        }
    });

    document.addEventListener('keydown', function(e) {
        if (isDrawingMode && drawPoints.length > 0 && (e.key === 'Backspace' || e.key === 'Delete')) {
            drawPoints.pop(); redrawLine(); 
            if (tempLine) map.removeLayer(tempLine);
            if (currentDrawMarkers.length > 0) map.removeLayer(currentDrawMarkers.pop());
        }
        if (isAreaMode && areaPoints.length > 0 && (e.key === 'Backspace' || e.key === 'Delete')) {
            areaPoints.pop(); 
            if (areaPolygon) map.removeLayer(areaPolygon);
            if (areaPoints.length > 0) {
                areaPolygon = L.polygon(areaPoints, { color: "#009900", fillColor: "#00FF00", fillOpacity: 0.3 }).addTo(map);
            }
        }
    });

    function redrawLine() {
        if (drawPolyline) map.removeLayer(drawPolyline);
        if (drawPoints.length > 0) {
            drawPolyline = L.polyline(drawPoints, { color: currentSelectedColor, weight: 5 }).addTo(map);
        } else { drawPolyline = null; }
    }

    // =========================================================
    // 7. ë§ˆì»¤ ë° ëª¨ë‹¬ ì²˜ë¦¬
    // =========================================================
    var tempMarkerData = null;
    map.on('contextmenu', function(e) {
        if (isDrawingMode) {
            if (drawPoints.length > 1) {
                var totalDistance = 0; for(var i=0; i<drawPoints.length-1; i++) totalDistance += map.distance(drawPoints[i], drawPoints[i+1]);
                var defaultName = "";
                var selectedSubwayVal = document.getElementById('subway-select').value;
                if(selectedSubwayVal) defaultName = subwayLines[selectedSubwayVal].name;
                
                var lineName = prompt(`ì´ ê±°ë¦¬: ${Math.round(totalDistance)}m\n\nì´ ì„ ì„ ì €ì¥í•˜ë ¤ë©´ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.`, defaultName);
                if (lineName) {
                    var newLine = { name: lineName, points: drawPoints, color: currentSelectedColor };
                    myLines.push(newLine); localStorage.setItem('hyobin_lines', JSON.stringify(myLines));
                    addLineToMap(newLine); alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");
                }
            }
            resetDrawMode(); 
            return;
        }

        if (isAreaMode) {
            if (areaPoints.length < 3) { alert("ë©´ì ì„ ì¸¡ì •í•˜ë ¤ë©´ ìµœì†Œ 3ê°œì˜ ì ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
            
            var areaSum = 0;
            for (var i = 0; i < areaPoints.length; i++) {
                var p1 = areaPoints[i];
                var p2 = areaPoints[(i + 1) % areaPoints.length];
                areaSum += (p1[1] * p2[0] - p2[1] * p1[0]); 
            }
            var finalArea = Math.abs(areaSum) / 2.0;
            var areaStr = formatArea(finalArea); // ì„¤ì •ëœ ë‹¨ìœ„ ì‚¬ìš©

            var center = L.polygon(areaPoints).getBounds().getCenter();
            var resultMarker = L.marker(center, {
                icon: L.divIcon({
                    className: 'area-result-wrap',
                    html: `<div class="area-result-badge">ë©´ì : ${areaStr}</div>`,
                    iconSize: null,
                    iconAnchor: [40, 15]
                })
            }).addTo(map);

            resultMarker.on('dblclick', function() {
                map.removeLayer(resultMarker);
                map.removeLayer(areaPolygon);
            });

            resultMarker.linkedPolygon = areaPolygon;
            resultMarker.on('dblclick', function(e) {
                map.removeLayer(this);
                if (this.linkedPolygon) map.removeLayer(this.linkedPolygon);
            });

            areaPolygon = null; 

            resetAreaMode(); 
            return;
        }

        var name = prompt("ë§ˆì»¤ ì´ë¦„:"); if (!name) return;
        tempMarkerData = { name: name, lat: Math.round(e.latlng.lat), lng: Math.round(e.latlng.lng) };
        openColorModal();
    });

    function openColorModal() {
        var modal = document.getElementById('color-modal'); var container = document.getElementById('modal-color-buttons'); container.innerHTML = "";
        regionColors.forEach(function(rc) {
            var btn = document.createElement('div'); btn.className = 'color-btn'; btn.style.backgroundColor = rc.code; btn.innerHTML = rc.name; 
            btn.onclick = function() { selectMarkerColor(rc.code); }; container.appendChild(btn);
        });
        modal.style.display = 'flex';
    }
    
    function selectMarkerColor(color) {
        if (tempMarkerData) {
            var item = { name: tempMarkerData.name, lat: tempMarkerData.lat, lng: tempMarkerData.lng, color: color, type: 'normal' };
            addMarkerToMap(item); myLandmarks.push(item); localStorage.setItem('hyobin_markers', JSON.stringify(myLandmarks));
        } closeModal('color-modal');
    }

    function openStationModal() {
        document.getElementById('station-name-input').value = "";
        var checkboxes = document.querySelectorAll('input[name="stationLine"]');
        checkboxes.forEach(cb => cb.checked = false);
        document.getElementById('station-modal').style.display = 'flex';
    }

    function confirmAddStation() {
        var name = document.getElementById('station-name-input').value;
        if (!name) { alert("ì—­ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”."); return; }

        var checkedBoxes = document.querySelectorAll('input[name="stationLine"]:checked');
        if (checkedBoxes.length === 0) { alert("ìµœì†Œ 1ê°œ ì´ìƒì˜ ë…¸ì„ ì„ ì„ íƒí•˜ì„¸ìš”."); return; }

        var selectedLines = [];
        checkedBoxes.forEach(function(cb) {
            selectedLines.push(cb.value); 
        });

        var stationData = {
            name: name,
            lat: tempClickLatLng.lat,
            lng: tempClickLatLng.lng,
            type: 'subway',
            lines: selectedLines
        };

        addMarkerToMap(stationData);
        myLandmarks.push(stationData);
        localStorage.setItem('hyobin_markers', JSON.stringify(myLandmarks));
        
        closeModal('station-modal');
        toggleStationMode(); 
    }

    function closeModal(id) { document.getElementById(id).style.display = 'none'; tempMarkerData = null; tempClickLatLng = null; }

    // =========================================================
    // 8. ê²€ìƒ‰, íŒŒì¼ê´€ë¦¬, ë…¸ì„ ë„ ëª¨ë“œ
    // =========================================================
    function searchLocation() {
        var input = document.getElementById('search-input').value.trim();
        if(!input) return;

        var target = allLandmarks.find(m => m.name.includes(input));
        if (target) {
            if (target.type === 'subway' && !map.hasLayer(subwayStationLayer)) {
                map.addLayer(subwayStationLayer);
            }
            map.flyTo([target.lat, target.lng], -1);
            L.popup().setLatLng([target.lat, target.lng]).setContent(`<b>${target.name}</b>`).openOn(map);
            return;
        }

        var poly = searchablePolygons.find(p => p.name.includes(input));
        if (poly) {
            var bounds = L.polygon(poly.points).getBounds();
            map.fitBounds(bounds);
            L.popup().setLatLng(bounds.getCenter()).setContent(`<b>${poly.name}</b>`).openOn(map);
            return;
        }

        alert("ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    function downloadMapImage() {
        var btn = document.getElementById('capture-btn');
        var originalText = btn.innerHTML;
        btn.innerHTML = "ğŸ“¸ ì°°ì¹µ!...";

        var controls = document.querySelector('.leaflet-control-container');
        if(controls) controls.style.display = 'none';

        html2canvas(document.getElementById('map'), {
            allowTaint: true,
            useCORS: true, 
            logging: false,
            scale: 2 
        }).then(function(canvas) {
            var link = document.createElement('a');
            link.download = 'hyobin_map_capture.png';
            link.href = canvas.toDataURL();
            link.click();

            if(controls) controls.style.display = 'block';
            btn.innerHTML = originalText;
            alert("ì§€ë„ ì´ë¯¸ì§€ê°€ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!");
        }).catch(function(err) {
            alert("ìº¡ì²˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + err);
            if(controls) controls.style.display = 'block';
            btn.innerHTML = originalText;
        });
    }

    function saveData() {
        if (myLandmarks.length === 0 && myLines.length === 0) { alert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }
        
        var data = {
            markers: myLandmarks,
            lines: myLines
        };
        var blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        var url = URL.createObjectURL(blob);
        var a = document.createElement("a");
        a.href = url;
        a.download = "hyobin_map_data.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function loadData(input) {
        var file = input.files[0];
        if(!file) return;

        if(!confirm("í˜„ì¬ ì§€ë„ì˜ ë°ì´í„°ê°€ íŒŒì¼ ë‚´ìš©ìœ¼ë¡œ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤.\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            input.value = ""; return;
        }

        var reader = new FileReader();
        reader.onload = function(e) {
            try {
                var data = JSON.parse(e.target.result);
                if (data.markers && Array.isArray(data.markers)) {
                    myLandmarks = data.markers;
                    localStorage.setItem('hyobin_markers', JSON.stringify(myLandmarks));
                }
                if (data.lines && Array.isArray(data.lines)) {
                    myLines = data.lines;
                    localStorage.setItem('hyobin_lines', JSON.stringify(myLines));
                }
                alert("ë°ì´í„° ë³µì› ì™„ë£Œ! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.");
                location.reload();
            } catch (err) {
                alert("íŒŒì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() { 
        if(confirm("ëª¨ë“  ì‚¬ìš©ì ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) { 
            localStorage.removeItem('hyobin_markers'); 
            localStorage.removeItem('hyobin_lines'); 
            localStorage.removeItem(migrationKey); 
            location.reload(); 
        } 
    }

    var isSubwayMode = false;
    var savedLayerState = [];

    function toggleSubwayMode() {
        isSubwayMode = !isSubwayMode;
        var btn = document.getElementById('mode-btn');
        var mapDiv = document.getElementById('map');
        var backgroundLayers = [imageLayerGroup, guGunLayer, adminLayer, legalLayer, devLayer];
        var filterBox = document.getElementById('subway-filter-box');

        if (isSubwayMode) {
            btn.innerHTML = "ğŸ—ºï¸ ì§€ë„ ëª¨ë“œ"; 
            btn.classList.add('active-btn');
            mapDiv.style.backgroundColor = '#ffffff'; 
            filterBox.style.display = 'block'; 

            savedLayerState = [];
            backgroundLayers.forEach(layer => {
                if (map.hasLayer(layer)) {
                    savedLayerState.push(layer);
                    map.removeLayer(layer);
                }
            });

            if (!map.hasLayer(subwayLineLayer)) map.addLayer(subwayLineLayer);
            if (!map.hasLayer(subwayStationLayer)) map.addLayer(subwayStationLayer);
            alert("ë…¸ì„ ë„ë§Œ ê¹”ë”í•˜ê²Œ ë³´ì—¬ì¤ë‹ˆë‹¤. (ì¢Œì¸¡ í•˜ë‹¨ì—ì„œ ë…¸ì„ ë³„ í•„í„°ë§ ê°€ëŠ¥)");
            applySubwayFilter(); 

        } else {
            btn.innerHTML = "ğŸš‡ ë…¸ì„ ë„ ëª¨ë“œ";
            btn.classList.remove('active-btn');
            mapDiv.style.backgroundColor = '#aaddff'; 
            filterBox.style.display = 'none'; 

            savedLayerState.forEach(layer => {
                if (!map.hasLayer(layer)) map.addLayer(layer);
            });
            if (!map.hasLayer(imageLayerGroup)) map.addLayer(imageLayerGroup);
            
            subwayLineLayer.eachLayer(layer => map.addLayer(layer));
            subwayStationLayer.eachLayer(layer => map.addLayer(layer));
        }
    }

    function toggleAllSubwayFilters(isChecked) {
        var checkboxes = document.querySelectorAll('input[name="subwayFilter"]');
        checkboxes.forEach(cb => cb.checked = isChecked);
        applySubwayFilter();
    }

    function applySubwayFilter() {
        if (!isSubwayMode) return;

        var checkedLines = [];
        document.querySelectorAll('input[name="subwayFilter"]:checked').forEach(cb => checkedLines.push(cb.value));

        subwayLineLayer.eachLayer(function(layer) {
            if (checkedLines.includes(layer.lineCode)) {
                if (!map.hasLayer(layer)) map.addLayer(layer);
            } else {
                if (map.hasLayer(layer)) map.removeLayer(layer);
            }
        });

        subwayStationLayer.eachLayer(function(marker) {
            var stationLines = marker.lineCodes || [];
            var isVisible = stationLines.some(code => checkedLines.includes(code));
            
            if (isVisible) {
                if (!map.hasLayer(marker)) map.addLayer(marker);
            } else {
                if (map.hasLayer(marker)) map.removeLayer(marker);
            }
        });

        if (isAutoDistMode) {
            autoDistanceLabels.forEach(function(lbl) {
                if (checkedLines.includes(lbl.relatedLineId)) {
                    if (!map.hasLayer(lbl)) map.addLayer(lbl);
                } else {
                    if (map.hasLayer(lbl)) map.removeLayer(lbl);
                }
            });
        }
    }

    map.on('overlayadd', function() { if(isDistrictAreaMode) updateDistrictAreaLabels(); });
    map.on('overlayremove', function() { if(isDistrictAreaMode) updateDistrictAreaLabels(); });
</script>
</body>
</html>